<!DOCTYPE html> 
<html> 
<head> <title>Quantization</title> 
<meta charset="UTF-8" /> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)" /> 
<link rel="stylesheet" type="text/css" href="index.css" /> 
<script type="text/javascript" 
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" 
></script> 
<style type="text/css"> 
.MathJax_MathML {text-indent: 0;} 
</style> 
</head><body 
>
   <div class="maketitle">
                                                                  

                                                                  
                                                                  

                                                                  

<h2 class="titleHead">Quantization</h2>
 <div class="author" ><span 
class="ecrm-1200">Vicente Gonz</span><span 
class="ecrm-1200">á</span><span 
class="ecrm-1200">lez Ruiz</span></div><br />
<div class="date" ><span 
class="ecrm-1200">January 25, 2020</span></div>
   </div>
   <h3 class="sectionHead"><span class="titlemark">1   </span> <a 
 id="x1-10001"></a><a 
href="https://en.wikipedia.org/wiki/Quantization_(signal_processing)" >Basics</a></h3>
     <ul class="itemize1">
     <li class="itemize">A quantizer discretizes the amplitude of a <a 
href="https://en.wikipedia.org/wiki/Pulse-amplitude_modulation" >PAM signal</a> <!--l. 16--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>s</mi><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>n</mi><msub><mrow 
><mi 
>T</mi></mrow><mrow 
><mi 
>s</mi></mrow></msub 
></mrow><mo 
class="MathClass-close">)</mo></mrow></mrow></math>
     (where <!--l. 16--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>s</mi></math>
     is an analog signal, <!--l. 17--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>n</mi> <mo 
class="MathClass-rel">∈</mo> <mi 
>ℤ</mi></math>
     and <!--l. 17--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>T</mi></mrow><mrow 
><mi 
>s</mi></mrow></msub 
></math>
     is sampling period), producing an analog <a 
href="https://en.wikipedia.org/wiki/Pulse-code_modulation" >PCM signal</a> <!--l. 20--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>s</mi><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi 
>n</mi></mrow><mo 
class="MathClass-close">]</mo></mrow></math>.
     Therefore, quantization maps the real (analog) values of samples into a
     discrete set of real values, also <span class="cite">[<a 
href="#Xvetterli1995wavelets">2</a>]</span>.
     </li>
     <li class="itemize">The quantization process can be modeled as <table class="equation"><tr><td> <a 
 id="x1-1001r1"></a>
     <!--l. 26--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                    <mi 
>s</mi><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi 
>n</mi></mrow><mo 
class="MathClass-close">]</mo></mrow> <mo 
class="MathClass-rel">=</mo> <mi 
>s</mi><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>n</mi><msub><mrow 
><mi 
>T</mi></mrow><mrow 
><mi 
>s</mi></mrow></msub 
></mrow><mo 
class="MathClass-close">)</mo></mrow> <mo 
class="MathClass-bin">+</mo> <mi 
>e</mi><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>n</mi><msub><mrow 
><mi 
>T</mi></mrow><mrow 
><mi 
>s</mi></mrow></msub 
></mrow><mo 
class="MathClass-close">)</mo></mrow><mo 
class="MathClass-punc">,</mo>
</math></td><td class="eq-no">(1)</td></tr></table>
     <!--l. 29--><p class="noindent" >being <!--l. 29--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>e</mi><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>n</mi><msub><mrow 
><mi 
>T</mi></mrow><mrow 
><mi 
>s</mi></mrow></msub 
></mrow><mo 
class="MathClass-close">)</mo></mrow></mrow></math>
     the quantization error (also called, quantization noise). Therefore, quantization
     produces a loss of information.
                                                                  

                                                                  
     </p></li>
     <li class="itemize">Quantizers are deﬁned from their set of
     <!--l. 33--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><msub><mrow 
><mi 
>d</mi></mrow><mrow 
><mi 
>i</mi></mrow></msub 
><mo 
class="MathClass-punc">;</mo><mi 
>i</mi> <mo 
class="MathClass-rel">∈</mo> <mi 
>ℤ</mi></mrow></math> (decision levels)
     and <!--l. 34--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><msub><mrow 
><mi 
>r</mi></mrow><mrow 
><mi 
>i</mi></mrow></msub 
><mo 
class="MathClass-punc">;</mo><mi 
>i</mi> <mo 
class="MathClass-rel">∈</mo> <mi 
>ℤ</mi></mrow></math> (representation
     levels). <!--l. 35--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow ><mo 
class="MathClass-open">{</mo><mrow><msub><mrow 
><mi 
>r</mi></mrow><mrow 
><mi 
>i</mi></mrow></msub 
></mrow><mo 
class="MathClass-close">}</mo></mrow></math>
     must be ﬁnite.
     </li>
     <li class="itemize">Another design parameter of quantizers is the deﬁnition of the decision boundaries
     <!--l. 38--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>d</mi></mrow><mrow 
><mstyle 
class="text"><mtext  >m</mtext></mstyle><mi 
>i</mi><mi 
>n</mi></mrow></msub 
></math> and
     <!--l. 38--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>d</mi></mrow><mrow 
><mstyle 
class="text"><mtext  >m</mtext></mstyle><mi 
>a</mi><mi 
>x</mi></mrow></msub 
></math>,
     (<!--l. 38--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>d</mi></mrow><mrow 
><mstyle 
class="text"><mtext  >m</mtext></mstyle><mi 
>i</mi><mi 
>n</mi></mrow></msub 
> <mo 
class="MathClass-rel">&#x003C;</mo> <msub><mrow 
><mi 
>d</mi></mrow><mrow 
><mstyle 
class="text"><mtext  >m</mtext></mstyle><mi 
>a</mi><mi 
>x</mi></mrow></msub 
></math>)
     that deﬁne the low and high overload regions as <table class="equation"><tr><td> <a 
 id="x1-1002r2"></a>
     <!--l. 40--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
<mi 
>s</mi><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi 
>n</mi></mrow><mo 
class="MathClass-close">]</mo></mrow> <mo 
class="MathClass-rel">=</mo> <mrow ><mo 
class="MathClass-open">{</mo><mrow><mtable  align="axis" style=""  
equalrows="false" columnlines="none" equalcolumns="false" class="array"><mtr><mtd 
class="array"  columnalign="left"> <msub><mrow 
><mi 
>r</mi></mrow><mrow 
><mstyle 
class="text"><mtext  >m</mtext></mstyle><mi 
>i</mi><mi 
>n</mi></mrow></msub 
>                </mtd><mtd 
class="array"  columnalign="left">  <mstyle 
class="text"><mtext  >if </mtext><mstyle 
class="math"><mi 
>s</mi><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>n</mi><msub><mrow 
><mi 
>T</mi></mrow><mrow 
><mi 
>s</mi></mrow></msub 
></mrow><mo 
class="MathClass-close">)</mo></mrow> <mo 
class="MathClass-rel">&#x003C;</mo> <msub><mrow 
><mi 
>d</mi></mrow><mrow 
><mstyle 
class="text"><mtext  >m</mtext></mstyle><mi 
>i</mi><mi 
>n</mi></mrow></msub 
></mstyle><mtext  ></mtext></mstyle>  </mtd>
</mtr><mtr><mtd 
class="array"  columnalign="left">  <msub><mrow 
><mi 
>r</mi></mrow><mrow 
><mstyle 
class="text"><mtext  >m</mtext></mstyle><mi 
>a</mi><mi 
>x</mi></mrow></msub 
>                 </mtd><mtd 
class="array"  columnalign="left">  <mstyle 
class="text"><mtext  >if </mtext><mstyle 
class="math"><mi 
>s</mi><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>n</mi><msub><mrow 
><mi 
>T</mi></mrow><mrow 
><mi 
>s</mi></mrow></msub 
></mrow><mo 
class="MathClass-close">)</mo></mrow> <mo 
class="MathClass-rel">&#x003E;</mo> <msub><mrow 
><mi 
>d</mi></mrow><mrow 
><mstyle 
class="text"><mtext  >m</mtext></mstyle><mi 
>a</mi><mi 
>x</mi></mrow></msub 
></mstyle><mtext  ></mtext></mstyle>  </mtd>
</mtr><mtr><mtd 
class="array"  columnalign="left">  <mi 
>s</mi><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>n</mi><msub><mrow 
><mi 
>T</mi></mrow><mrow 
><mi 
>s</mi></mrow></msub 
></mrow><mo 
class="MathClass-close">)</mo></mrow> <mo 
class="MathClass-bin">+</mo> <mi 
>e</mi><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>n</mi><msub><mrow 
><mi 
>T</mi></mrow><mrow 
><mi 
>s</mi></mrow></msub 
></mrow><mo 
class="MathClass-close">)</mo></mrow> </mtd><mtd 
class="array"  columnalign="left">  <mstyle 
class="text"><mtext  >otherwise</mtext></mstyle><mo 
class="MathClass-punc">.</mo>         </mtd></mtr><!--ll--></mtable>
</math></td><td class="eq-no">(2)</td></tr></table>
     </li>
     <li class="itemize">The performance of the quantizer is measured as the distance between the input
     <!--l. 49--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math> and the
     output <!--l. 49--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>y</mi></math>
     <table class="equation-star"><tr><td>
     <!--l. 50--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                  <mi 
>d</mi><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>x</mi><mo 
class="MathClass-punc">,</mo><mi 
>y</mi></mrow><mo 
class="MathClass-close">)</mo></mrow> <mo 
class="MathClass-rel">=</mo> <mo 
class="MathClass-rel">|</mo><mi 
>x</mi> <mo 
class="MathClass-bin">−</mo> <mi 
>y</mi><msup><mrow 
><mo 
class="MathClass-rel">|</mo></mrow><mrow 
><mn>2</mn></mrow></msup 
><mo 
class="MathClass-punc">.</mo>
</math></td></tr></table>
     <!--l. 53--><p class="noindent" >Thus, the MSE is </p><table class="equation"><tr><td> <a 
 id="x1-1003r3"></a>
                                                                  

                                                                  
     <!--l. 54--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                 <mstyle 
class="text"><mtext  >MSE</mtext></mstyle> <mo 
class="MathClass-rel">=</mo> <mi 
>E</mi><mrow ><mo 
class="MathClass-open">(</mo><mrow><mo 
class="MathClass-rel">|</mo><mi 
>x</mi> <mo 
class="MathClass-bin">−</mo> <mi 
>y</mi><msup><mrow 
><mo 
class="MathClass-rel">|</mo></mrow><mrow 
><mn>2</mn></mrow></msup 
></mrow><mo 
class="MathClass-close">)</mo></mrow> <mo 
class="MathClass-rel">=</mo><munder class="msub"><mrow 
><mo mathsize="big" 
> ∑</mo>
   </mrow><mrow 
><mi 
>i</mi></mrow></munder 
><msubsup><mrow 
><mo> ∫
 <!--nolimits--></mo><!--nolimits--></mrow><mrow 
><msub><mrow 
><mi 
>x</mi></mrow><mrow 
><mi 
>i</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msub 
></mrow><mrow 
><msub><mrow 
><mi 
>x</mi></mrow><mrow 
><mi 
>i</mi></mrow></msub 
>
         </mrow></msubsup 
><msup><mrow 
><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>x</mi> <mo 
class="MathClass-bin">−</mo> <msub><mrow 
><mi 
>y</mi></mrow><mrow 
><mi 
>i</mi></mrow></msub 
></mrow><mo 
class="MathClass-close">)</mo></mrow></mrow><mrow 
><mn>2</mn></mrow></msup 
><msub><mrow 
><mi 
>f</mi></mrow><mrow 
>
<mi 
>X</mi></mrow></msub 
><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>x</mi></mrow><mo 
class="MathClass-close">)</mo></mrow><mi 
>d</mi><mi 
>x</mi><mo 
class="MathClass-punc">,</mo>
</math></td><td class="eq-no">(3)</td></tr></table>
     <!--l. 57--><p class="noindent" >where <!--l. 57--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>d</mi></mrow><mrow 
><mi 
>X</mi></mrow></msub 
><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>x</mi></mrow><mo 
class="MathClass-close">)</mo></mrow></math>
     is the probability density function (PDF) of
     <!--l. 57--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math> and
     <!--l. 58--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>E</mi><mrow ><mo 
class="MathClass-open">(</mo><mrow><mo 
class="MathClass-bin">⋅</mo></mrow><mo 
class="MathClass-close">)</mo></mrow></math>
     the expectation.
</p>
     </li></ul>
<!--l. 62--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">2   </span> <a 
 id="x1-20002"></a>Scalar quantization</h3>
     <ul class="itemize1">
     <li class="itemize">For the sake of simplicity, lets denote <!--l. 64--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi> <mo 
class="MathClass-rel">=</mo> <mrow ><mo 
class="MathClass-open">{</mo><mrow><mi 
>s</mi><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>n</mi><msub><mrow 
><mi 
>T</mi></mrow><mrow 
><mi 
>s</mi></mrow></msub 
></mrow><mo 
class="MathClass-close">)</mo></mrow></mrow><mo 
class="MathClass-close">}</mo></mrow></math>
     as the inputs of the quantizer and <!--l. 65--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>y</mi> <mo 
class="MathClass-rel">=</mo> <mrow ><mo 
class="MathClass-open">{</mo><mrow><mi 
>s</mi><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi 
>n</mi></mrow><mo 
class="MathClass-close">]</mo></mrow></mrow><mo 
class="MathClass-close">}</mo></mrow></math>
     as the outputs. In a scalar quantizer, each input sample <!--l. 66--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>x</mi></mrow><mrow 
><mi 
>i</mi></mrow></msub 
></math>
     is individually quantized as <!--l. 67--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>y</mi></mrow><mrow 
><mi 
>i</mi></mrow></msub 
></math>.
     </li>
     <li class="itemize">The quantization error <table class="equation"><tr><td> <a 
 id="x1-2001r4"></a>
     <!--l. 70--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                              <mi 
>e</mi> <mo 
class="MathClass-rel">=</mo> <mi 
>y</mi> <mo 
class="MathClass-bin">−</mo> <mi 
>x</mi>
</math></td><td class="eq-no">(4)</td></tr></table>
                                                                  

                                                                  
     <!--l. 73--><p class="noindent" >can be modeled as a noise process which: (1) is uncorrelated to
     the input, (2) is white, and (3) follows a uniform distribution.
     However, notice that this is a fair approximation only if
     <!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>Δ</mi> <mo 
class="MathClass-rel">&#x003C;</mo><mo 
class="MathClass-rel">&#x003C;</mo> <msub><mrow 
><mi 
>σ</mi></mrow><mrow 
><mi 
>x</mi></mrow></msub 
></math> <span class="cite">[<a 
href="#Xvetterli1995wavelets">2</a>]</span>.
</p>
     </li></ul>
<!--l. 80--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">3   </span> <a 
 id="x1-30003"></a>Uniform (lineal) scalar quantization</h3>
     <ul class="itemize1">
     <li class="itemize">In an uniform quantizer, the quantization step
     <!--l. 84--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>Δ</mi></mrow></math>
     satisﬁes that the input range is divided into intervals <table class="equation"><tr><td> <a 
 id="x1-3001r5"></a>
     <!--l. 86--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                <mi 
>Δ</mi> <mo 
class="MathClass-rel">=</mo> <msub><mrow 
><mi 
>d</mi></mrow><mrow 
><mi 
>i</mi><mo 
class="MathClass-bin">+</mo><mn>1</mn></mrow></msub 
> <mo 
class="MathClass-bin">−</mo> <msub><mrow 
><mi 
>d</mi></mrow><mrow 
><mi 
>i</mi></mrow></msub 
> <mo 
class="MathClass-rel">=</mo> <msub><mrow 
><mi 
>r</mi></mrow><mrow 
><mi 
>i</mi><mo 
class="MathClass-bin">+</mo><mn>1</mn></mrow></msub 
> <mo 
class="MathClass-bin">−</mo> <msub><mrow 
><mi 
>r</mi></mrow><mrow 
><mi 
>i</mi></mrow></msub 
><mo 
class="MathClass-punc">,</mo><mo 
class="MathClass-op">∀</mo><mi 
>i</mi><mo 
class="MathClass-punc">.</mo>
</math></td><td class="eq-no">(5)</td></tr></table>
     <!--l. 89--><p class="noindent" >Notice that, all the intervals have the same size and that </p><table class="equation"><tr><td> <a 
 id="x1-3002r6"></a>
     <!--l. 90--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                               <mi 
>Q</mi> <mo 
class="MathClass-rel">=</mo>  <mfrac><mrow 
><mn>1</mn></mrow> 
<mrow 
><mi 
>Δ</mi></mrow></mfrac><mo 
class="MathClass-punc">.</mo>
</math></td><td class="eq-no">(6)</td></tr></table>
     <!--l. 93--><p class="noindent" >It also holds that </p><table class="equation"><tr><td> <a 
 id="x1-3003r7"></a>
                                                                  

                                                                  
     <!--l. 94--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                            <mi 
>Δ</mi> <mo 
class="MathClass-rel">=</mo> <mfrac><mrow 
><mi 
>b</mi> <mo 
class="MathClass-bin">−</mo> <mi 
>a</mi></mrow> 
  <mrow 
><mi 
>Q</mi></mrow></mfrac>  <mo 
class="MathClass-punc">.</mo>
</math></td><td class="eq-no">(7)</td></tr></table>
     </li>
     <li class="itemize">Under the premise that <!--l. 99--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>e</mi></math>
     is  uniform,  and  considering  that
     <!--l. 100--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>y</mi></mrow><mrow 
><mi 
>i</mi></mrow></msub 
> <mo 
class="MathClass-rel">=</mo> <mrow ><mo 
class="MathClass-open">(</mo><mrow><msub><mrow 
><mi 
>x</mi></mrow><mrow 
><mi 
>i</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msub 
> <mo 
class="MathClass-bin">+</mo> <msub><mrow 
><mi 
>x</mi></mrow><mrow 
><mi 
>i</mi></mrow></msub 
></mrow><mo 
class="MathClass-close">)</mo></mrow><mo 
class="MathClass-bin">∕</mo><mn>2</mn></math> (something quite
     reasonable when <!--l. 100--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math>
     can be considered also uniform) the average quantization error is
     <!--l. 102--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mfrac><mrow 
><mi 
>Z</mi></mrow>
<mrow 
><mn>4</mn></mrow></mfrac> </math>
     (<!--l. 102--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mfrac><mrow 
><mi 
>Z</mi></mrow>
<mrow 
><mn>2</mn></mrow></mfrac> </math> is the
     meximum and <!--l. 102--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mn>0</mn></math>
     is the minimum), and for this particular case <table class="equation"><tr><td> <a 
 id="x1-3004r8"></a>
     <!--l. 104--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                              <mstyle 
class="text"><mtext  >MSE</mtext></mstyle> <mo 
class="MathClass-rel">=</mo>  <mfrac><mrow 
><mn>1</mn></mrow> 
<mrow 
><mi 
>Δ</mi></mrow></mfrac><msubsup><mrow 
><mo 
class="MathClass-op">∫
 <!--nolimits--></mo><!--nolimits--></mrow><mrow 
><mo 
class="MathClass-bin">−</mo><mi 
>Δ</mi><mo 
class="MathClass-bin">∕</mo><mn>2</mn></mrow><mrow 
><mi 
>Δ</mi><mo 
class="MathClass-bin">∕</mo><mn>2</mn></mrow></msubsup 
><msup><mrow 
><mi 
>e</mi></mrow><mrow 
><mn>2</mn></mrow></msup 
><mi 
>d</mi><mi 
>e</mi> <mo 
class="MathClass-rel">=</mo> <mfrac><mrow 
><msup><mrow 
><mi 
>Δ</mi></mrow><mrow 
><mn>2</mn></mrow></msup 
></mrow> 
 <mrow 
><mn>1</mn><mn>2</mn></mrow></mfrac> <mo 
class="MathClass-punc">.</mo>
</math></td><td class="eq-no">(8)</td></tr></table>
     </li>
     <li class="itemize">Uniform quantizers are used in most A/D (analogic/digital) converters, were
     it is expected the generation of uniformely distributed sequences of
     samples.
     </li>
     <li class="itemize">El error de cuantiﬁcación promedio en un cuantiﬁcador
     lineal depende del paso de cuantiﬁcación y es igual a
     <!--l. 126--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>Z</mi><mo 
class="MathClass-bin">∕</mo><mn>4</mn></math>
     (<!--l. 126--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>Z</mi><mo 
class="MathClass-bin">∕</mo><mn>2</mn></math> es el
     máximo y <!--l. 127--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mn>0</mn></math>
     el mínimo). Por tanto, <table class="equation-star"><tr><td>
                                                                  

                                                                  
     <!--l. 128--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                     <mover accent="false" 
class="mml-overline"><mrow><mstyle 
class="text"><mtext  >SNR</mtext></mstyle></mrow><mo 
accent="true">¯</mo></mover> <mo 
class="MathClass-rel">=</mo> <mfrac><mrow 
><munderover accentunder="false" accent="false"><mrow  
><mo mathsize="big" 
>∑</mo>
  </mrow><mrow 
><mi 
>n</mi><mo 
class="MathClass-rel">=</mo><mn>1</mn></mrow><mrow 
><mi 
>N</mi></mrow></munderover 
><mi 
>s</mi><msup><mrow 
><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>n</mi><msub><mrow 
><mi 
>T</mi></mrow><mrow 
>
<mi 
>s</mi></mrow></msub 
></mrow><mo 
class="MathClass-close">)</mo></mrow></mrow><mrow 
><mn>2</mn></mrow></msup 
></mrow> 
 <mrow 
><munderover accentunder="false" accent="false"><mrow  
><mo mathsize="big" 
> ∑</mo>
  </mrow><mrow 
><mi 
>n</mi><mo 
class="MathClass-rel">=</mo><mn>1</mn></mrow><mrow 
><mi 
>N</mi></mrow></munderover 
><msup><mrow 
><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>Z</mi><mo 
class="MathClass-bin">∕</mo><mn>4</mn></mrow><mo 
class="MathClass-close">)</mo></mrow></mrow><mrow 
><mn>2</mn></mrow></msup 
></mrow></mfrac>  <mo 
class="MathClass-rel">=</mo> <mfrac><mrow 
><munderover accentunder="false" accent="false"><mrow  
><mo mathsize="big" 
>∑</mo>
  </mrow><mrow 
><mi 
>n</mi><mo 
class="MathClass-rel">=</mo><mn>1</mn></mrow><mrow 
><mi 
>N</mi></mrow></munderover 
><mi 
>s</mi><msup><mrow 
><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>n</mi><msub><mrow 
><mi 
>T</mi></mrow><mrow 
>
<mi 
>s</mi></mrow></msub 
></mrow><mo 
class="MathClass-close">)</mo></mrow></mrow><mrow 
><mn>2</mn></mrow></msup 
></mrow> 
          <mrow 
><mi 
>N</mi> <mfrac><mrow 
><msup><mrow 
><mi 
>Z</mi></mrow><mrow 
><mn>2</mn></mrow></msup 
></mrow> 
<mrow 
><mn>1</mn><mn>6</mn></mrow></mfrac> </mrow></mfrac>        <mo 
class="MathClass-punc">.</mo>
</math></td></tr></table>
     </li>
     <li class="itemize">Como se puede apreciar de esta expresión, la relación señal/ruido promedio
     es directamente proporcional a la inversa del paso de cuantiﬁcación elevado a
     cuadrado, es decir, <table class="equation-star"><tr><td>
     <!--l. 138--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                            <mover accent="false" 
class="mml-overline"><mrow><mstyle 
class="text"><mtext  >SNR</mtext></mstyle></mrow><mo 
accent="true">¯</mo></mover> <mo 
class="MathClass-rel">∼</mo> <mfrac><mrow 
><mn>1</mn></mrow> 
<mrow 
><msup><mrow 
><mi 
>Z</mi></mrow><mrow 
><mn>2</mn></mrow></msup 
></mrow></mfrac><mo 
class="MathClass-punc">.</mo>
</math></td></tr></table>
     </li>
     <li class="itemize">Si  usamos  PCM  (Puse  Code
     Modulation)<span class="footnote-mark"><a 
href="index2.html#fn1x0"><sup class="textsuperscript">1</sup></a></span><a 
 id="x1-3005f1"></a> 
     para representar las muestras cuantiﬁcadas
     <!--l. 143--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>s</mi><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi 
>n</mi></mrow><mo 
class="MathClass-close">]</mo></mrow></math>,
     se cumple <table class="equation-star"><tr><td>
                                                                  

                                                                  
     <!--l. 144--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                               <mi 
>Z</mi> <mo 
class="MathClass-rel">∼</mo> <mfrac><mrow 
><mn>1</mn></mrow> 
<mrow 
><msup><mrow 
><mn>2</mn></mrow><mrow 
><mi 
>b</mi></mrow></msup 
></mrow></mfrac><mo 
class="MathClass-punc">,</mo>
</math></td></tr></table>
     <!--l. 147--><p class="noindent" >donde <!--l. 147--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>b</mi></math>
     es el número de bits utilizados para representar los niveles de representación.
     Es decir, a mayor número de bits, menor paso de cuantiﬁcación.
     </p></li>
     <li class="itemize">Por tanto, <table class="equation-star"><tr><td>
     <!--l. 151--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                       <mover accent="false" 
class="mml-overline"><mrow><mstyle 
class="text"><mtext  >SNR</mtext></mstyle></mrow><mo 
accent="true">¯</mo></mover> <mo 
class="MathClass-rel">∼</mo> <msup><mrow 
><mrow ><mo 
class="MathClass-open">(</mo><mrow><msup><mrow 
><mn>2</mn></mrow><mrow 
><mi 
>b</mi></mrow></msup 
></mrow><mo 
class="MathClass-close">)</mo></mrow></mrow><mrow 
><mn>2</mn></mrow></msup 
> <mo 
class="MathClass-rel">=</mo> <msup><mrow 
><mn>2</mn></mrow><mrow 
><mn>2</mn><mi 
>b</mi></mrow></msup 
><mo 
class="MathClass-punc">.</mo>
</math></td></tr></table>
     </li>
     <li class="itemize">Finalmente, “tomando Decibelios”, <table class="equation-star"><tr><td>
     <!--l. 155--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                       <mover accent="false" 
class="mml-overline"><mrow><msub><mrow 
><mstyle 
class="text"><mtext  >SNR</mtext></mstyle></mrow><mrow 
><mstyle 
class="text"><mtext  >dB</mtext></mstyle></mrow></msub 
></mrow><mo 
accent="true">¯</mo></mover> <mo 
class="MathClass-rel">∼</mo> <mn>1</mn><mn>0</mn><msub><mrow 
><mo class="qopname">log</mo><!--nolimits--></mrow><mrow 
><mn>1</mn><mn>0</mn></mrow></msub 
><msup><mrow 
><mn>2</mn></mrow><mrow 
><mn>2</mn><mi 
>b</mi></mrow></msup 
> <mo 
class="MathClass-rel">=</mo> <mn>2</mn><mn>0</mn><mi 
>b</mi><msub><mrow 
><mo class="qopname">log</mo><!--nolimits--></mrow><mrow 
>
<mn>1</mn><mn>0</mn></mrow></msub 
><mn>2</mn> <mo 
class="MathClass-rel">≈</mo> <mn>6</mn><mi 
>b</mi><mspace width="1em" class="nbsp" /><mstyle 
class="text"><mtext  >dB</mtext></mstyle><mo 
class="MathClass-punc">.</mo>
</math></td></tr></table>
                                                                  

                                                                  
     </li>
     <li class="itemize">Este resultado es interesante porque indica que, en un sistema PCM, con cada
     bit de precisión mejoramos la calidad de la señal digitalizada en un factor de
     <!--l. 162--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mn>6</mn></math> dB. Si
     consideramos que para alcanzar una calidad HiFi (High Fidelity) en audio debemos
     conseguir <!--l. 164--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mn>9</mn><mn>6</mn></math>
     dB de relación señal/ruido, deberemos usar
<div class="math-display"><!--l. 165--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" ><mrow 
>
                        <mfrac><mrow 
><mn>9</mn><mn>6</mn></mrow>
 <mrow 
><mn>6</mn></mrow></mfrac> <mo 
class="MathClass-rel">=</mo> <mn>1</mn><mn>6</mn><mspace width="1em" class="nbsp" /><mstyle 
class="text"><mtext  >bits/muestra</mtext></mstyle><mo 
class="MathClass-punc">,</mo>
</mrow></math></div>
     <!--l. 167--><p class="nopar" >
     valor que coincide con la resolución usada en los CDs de audio!
</p>
     </li></ul>
<!--l. 172--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">3.1   </span> <a 
 id="x1-40003.1"></a>Using codewords (encoding)</h4>
     <ul class="itemize1">
     <li class="itemize">Depending on the number of <!--l. 177--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>Q</mi></mrow></math>
     diﬀerent possible values (or <span 
class="ecti-1000">bins</span>) for <!--l. 178--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>s</mi><mrow ><mo 
class="MathClass-open">[</mo><mrow><mo 
class="MathClass-bin">⋅</mo></mrow><mo 
class="MathClass-close">]</mo></mrow></mrow></math>,
     we speak of a <!--l. 179--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>q</mi> <mo 
class="MathClass-rel">=</mo> <mrow ><mo 
class="MathClass-open">⌈</mo><mrow><msub><mrow 
><mo class="qopname">log</mo><!--nolimits--></mrow><mrow 
><mn>2</mn></mrow></msub 
><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>Q</mi></mrow><mo 
class="MathClass-close">)</mo></mrow></mrow><mo 
class="MathClass-close">⌉</mo></mrow></mrow></math>-bits
     quantizer (this means that the output of the quantizer are <!--l. 180--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>q</mi></mrow></math>
     bits for each sample, or that we have <!--l. 181--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><msup><mrow 
><mn>2</mn></mrow><mrow 
><mi 
>q</mi></mrow></msup 
></mrow></math>
     representation levels). For the simple, <!--l. 181--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>r</mi></mrow><mrow 
><mi 
>i</mi></mrow></msub 
> <mo 
class="MathClass-rel">=</mo> <mi 
>i</mi></math>
     and the input intervals are of the form <!--l. 182--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow ><mo 
class="MathClass-open">(</mo><mrow><msub><mrow 
><mi 
>d</mi></mrow><mrow 
><mi 
>i</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msub 
><mo 
class="MathClass-punc">,</mo><msub><mrow 
><mi 
>d</mi></mrow><mrow 
><mi 
>i</mi></mrow></msub 
></mrow><mo 
class="MathClass-close">]</mo></mrow> <mo 
class="MathClass-rel">=</mo> <mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>i</mi> <mo 
class="MathClass-bin">−</mo> <mn>1</mn><mo 
class="MathClass-bin">∕</mo><mn>2</mn><mo 
class="MathClass-punc">,</mo><mi 
>i</mi> <mo 
class="MathClass-bin">+</mo> <mn>1</mn><mo 
class="MathClass-bin">∕</mo><mn>2</mn></mrow><mo 
class="MathClass-close">]</mo></mrow></math>.
     </li>
     <li class="itemize">When we quantize digital signals, these are sequences of digital samples
     represented by symbols of a given alphabet, typically, a subset of <!--l. 187--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>ℤ</mi></mrow></math>
     or <!--l. 187--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>ℕ</mi></mrow></math>.
     Therefore, both the input and the output of the quantizer are indexes, not
                                                                  

                                                                  
     real values of a sampled signal. The set <!--l. 189--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow ><mo 
class="MathClass-open">{</mo><mrow><msub><mrow 
><mi 
>r</mi></mrow><mrow 
><mi 
>i</mi></mrow></msub 
></mrow><mo 
class="MathClass-close">}</mo></mrow></math>
     is called the codebook and the <!--l. 190--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>r</mi></mrow><mrow 
><mi 
>i</mi></mrow></msub 
></math>
     the codewords.
     </li>
     <li class="itemize">If <!--l. 192--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>R</mi></math> is the number of
     bits of the quantizer, <!--l. 192--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>Δ</mi></math>
     decreases as <!--l. 193--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mfrac><mrow 
><mn>1</mn></mrow>
<mrow 
><msup><mrow 
><mn>2</mn></mrow><mrow 
><mi 
>R</mi></mrow></msup 
></mrow></mfrac></math>,
     and <table class="equation"><tr><td> <a 
 id="x1-4001r9"></a>
     <!--l. 194--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                           <mstyle 
class="text"><mtext  >MSE</mtext></mstyle> <mo 
class="MathClass-rel">=</mo> <mfrac><mrow 
><msup><mrow 
><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>b</mi> <mo 
class="MathClass-bin">−</mo> <mi 
>a</mi></mrow><mo 
class="MathClass-close">)</mo></mrow></mrow><mrow 
><mn>2</mn></mrow></msup 
></mrow> 
  <mrow 
><mn>1</mn><mn>2</mn><msup><mrow 
><mi 
>Q</mi></mrow><mrow 
><mn>2</mn></mrow></msup 
></mrow></mfrac>    <mo 
class="MathClass-rel">=</mo> <msup><mrow 
><mi 
>σ</mi></mrow><mrow 
><mn>2</mn></mrow></msup 
><msup><mrow 
><mn>2</mn></mrow><mrow 
><mo 
class="MathClass-bin">−</mo><mn>2</mn><mi 
>R</mi></mrow></msup 
> <mo 
class="MathClass-rel">=</mo> <mi 
>C</mi><msup><mrow 
><mn>2</mn></mrow><mrow 
><mo 
class="MathClass-bin">−</mo><mn>2</mn><mi 
>R</mi></mrow></msup 
><mo 
class="MathClass-punc">.</mo>
</math></td><td class="eq-no">(9)</td></tr></table>
     <!--l. 197--><p class="noindent" >since <!--l. 197--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msup><mrow 
><mi 
>σ</mi></mrow><mrow 
><mn>2</mn></mrow></msup 
> <mo 
class="MathClass-rel">=</mo> <mfrac><mrow 
><msup><mrow 
><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>b</mi><mo 
class="MathClass-bin">−</mo><mi 
>a</mi></mrow><mo 
class="MathClass-close">)</mo></mrow></mrow><mrow 
><mn>2</mn></mrow></msup 
></mrow> 
   <mrow 
><mn>1</mn><mn>2</mn></mrow></mfrac>   </math>
     for uniform input PDF.</p></li></ul>
<!--l. 203--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">3.2   </span> <a 
 id="x1-50003.2"></a>Example</h4>
<!--l. 204--><p class="noindent" >Quantize <a 
href="https://upload.wikimedia.org/wikipedia/commons/3/3a/Jfk_berlin_address_high.ogg" >Jfk_berlin_address_high.ogg</a> using
<!--l. 206--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>Δ</mi> <mo 
class="MathClass-rel">=</mo> <mn>2</mn></mrow></math>.
Compute the variance of both audio sequences.
</p><!--l. 208--><p class="noindent" >
</p>
   <h4 class="likesubsectionHead"><a 
 id="x1-60003.2"></a>Example (uniform quantization)</h4>
<!--l. 209--><p class="noindent" ><a 
href="https://nbviewer.jupyter.org/github/vicente-gonzalez-ruiz/quantization/blob/master/uniform_quantization.ipynb" >IPython notebook</a>
</p><!--l. 211--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">4   </span> <a 
 id="x1-70004"></a>Non-uniform quantization</h3>
                                                                  

                                                                  
     <ul class="itemize1">
     <li class="itemize">In order to minimize the maximun, average or the total quantization error,
     <!--l. 216--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>Δ</mi></mrow></math>
     can be adapted to the characteristics of <!--l. 216--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>s</mi></mrow></math>.</li></ul>
<!--l. 219--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">4.1   </span> <a 
 id="x1-80004.1"></a>Companded quantization</h4>
     <ul class="itemize1">
     <li class="itemize">Non-uniform quantizer.
     </li>
     <li class="itemize"><a 
href="https://en.wikipedia.org/wiki/Companding" >Companding</a>: COMpressing + exPANDING. The original signal is mapped
     through  a  compressor,  quantized  using  an  uniform  quantized,  and
     re-mapped using the corresponding expander. The result is a logarithmic
     quantization.
     </li>
     <li class="itemize"><a 
href="https://en.wikipedia.org/wiki/%CE%9C-law_algorithm" ><!--l. 229--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>μ</mi></mrow></math>-law</a>
     example:</li></ul>
<!--l. 233--><p class="noindent" ><a 
href="https://nbviewer.jupyter.org/github/vicente-gonzalez-ruiz/quantization/blob/master/companded_quantization.ipynb" >Ipython notebook</a>
</p><!--l. 235--><p class="indent" >   <div style="text-align:center;"> <img width=600 src="graphics/uniform.svg" /> </div>   <div style="text-align:center;"> <img width=600 src="graphics/ulaw-compressor.svg" /> </div>   <div style="text-align:center;"> <img width=600 src="graphics/ulaw-expander.svg" /> </div>   <div style="text-align:center;"> <img width=600 src="graphics/companded.svg" /> </div> 
</p><!--l. 240--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">5   </span> <a 
 id="x1-90005"></a>PDF-optimized quantization</h3>
     <ul class="itemize1">
     <li class="itemize">Non-uniform quantizer.
     </li>
     <li class="itemize">if we known the probability distribution of the samples, we can select a
     small <!--l. 246--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>Δ</mi></mrow></math>
     for the most probable samples and viceversa.</li></ul>
<!--l. 249--><p class="noindent" ><div style="text-align:center;"> <img width=600 src="graphics/cuantif_max-lloyd.svg" /> </div> 
                                                                  

                                                                  
</p><!--l. 251--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">6   </span> <a 
 id="x1-100006"></a>Adaptive quantization</h3>
     <ul class="itemize1">
     <li class="itemize">Useful when the characteristics of <!--l. 254--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>s</mi></mrow></math>
     (the variance, for example) vary over time.
     </li>
     <li class="itemize">Typically, the quantizer varies <!--l. 257--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>Δ</mi></mrow></math>
     depending on such characteristics.</li></ul>
<!--l. 261--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">7   </span> <a 
 id="x1-110007"></a>Forward adaptive quantization</h3>
     <ul class="itemize1">
     <li class="itemize">Used for determining a suitable <!--l. 264--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>Δ</mi></mrow></math>
     for blocks of samples.
     </li>
     <li class="itemize">  <a 
 id="encoder">
     <h5 class="subsubsectionHead"><span class="titlemark">7.0.1   </span> <a 
 id="x1-120007.0.1"></a>Encoder:</h5>
     <!--l. 267--><p class="noindent" ></a>
     </p><!--l. 269--><p class="noindent" >
         </p><ol  class="enumerate1" >
         <li 
  class="enumerate" id="x1-12002x1">While samples in <!--l. 273--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>s</mi></mrow></math>:
         <!--l. 275--><p class="noindent" >
             </p><ol  class="enumerate2" >
             <li 
  class="enumerate" id="x1-12004x1">Read into <!--l. 279--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>b</mi></mrow></math>
             the next <!--l. 279--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>B</mi></mrow></math>
             samples of <!--l. 279--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>s</mi></mrow></math>.
             </li>
             <li 
  class="enumerate" id="x1-12006x2">Determine <!--l. 281--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>Δ</mi></mrow></math>,
             minimizing the quantization error, and output <!--l. 282--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>Δ</mi></mrow></math>
             (or the data necessary for its determination).
             </li>
             <li 
  class="enumerate" id="x1-12008x3">Quantize <!--l. 284--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>b</mi></mrow></math>
             and output it.</li></ol>
                                                                  

                                                                  
         </li></ol>
     </li>
     <li class="itemize">  <a 
 id="decoder">
     <h5 class="subsubsectionHead"><span class="titlemark">7.0.2   </span> <a 
 id="x1-130007.0.2"></a>Decoder:</h5>
     <!--l. 289--><p class="noindent" ></a>
     </p><!--l. 291--><p class="noindent" >
         </p><ol  class="enumerate1" >
         <li 
  class="enumerate" id="x1-13002x1">While data in input:
         <!--l. 297--><p class="noindent" >
             </p><ol  class="enumerate2" >
             <li 
  class="enumerate" id="x1-13004x1">Read <!--l. 301--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>Δ</mi></mrow></math>
             (or the data necessary for determining it, and in this case, use
             the same algorithm that the used by the encoder).
             </li>
             <li 
  class="enumerate" id="x1-13006x2">“Dequantize” <!--l. 304--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>b</mi></mrow></math>
             and output it (note that the dequantization is only a way of
             calling the process of reverting the original range of the quantized
             signal).</li></ol>
         </li></ol>
     </li>
     <li class="itemize">The selection of <!--l. 310--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>B</mi></mrow></math>
     is a trade-oﬀ between the increase in side information needed by small block
     sizes and the loss of ﬁdelity due to large block sizes.
     </li>
     <li class="itemize">Forward adaptive quantization generates a
     <!--l. 315--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>B</mi><mstyle 
class="text"><mtext  >-samples</mtext></mstyle> <mo 
class="MathClass-bin">×</mo> <msub><mrow 
><mi 
>f</mi></mrow><mrow 
><mi 
>s</mi></mrow></msub 
></mrow></math> delay (buﬀering),
     where <!--l. 315--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><msub><mrow 
><mi 
>f</mi></mrow><mrow 
><mi 
>s</mi></mrow></msub 
></mrow></math> is the
     sampling rate of <!--l. 316--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>s</mi></mrow></math>.</li></ul>
<!--l. 319--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">8   </span> <a 
 id="x1-140008"></a>Backward adaptive quantization</h3>
     <ul class="itemize1">
     <li class="itemize">Only the previously quantized samples are available to use in adapting the
     quantizer.
                                                                  

                                                                  
     </li>
     <li class="itemize">Idea: If happens that <!--l. 325--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>Δ</mi></mrow></math>
     is smaller than it should be, the input will fall in the outer levels of the
     quantizer a high number of times. On the other hand, if <!--l. 327--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>Δ</mi></mrow></math>
     is larger than it should be, the samples will fall in the inner levels a high
     number of times.
     </li>
     <li class="itemize">  <a 
 id="encoder">
     <h5 class="subsubsectionHead"><span class="titlemark">8.0.1   </span> <a 
 id="x1-150008.0.1"></a>Encoder:</h5>
     <!--l. 331--><p class="noindent" ></a>
     </p><!--l. 333--><p class="noindent" >
         </p><ol  class="enumerate1" >
         <li 
  class="enumerate" id="x1-15002x1"><!--l. 337--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>Δ</mi> <mo 
class="MathClass-rel">←</mo> <mn>2</mn></mrow></math>.
         </li>
         <li 
  class="enumerate" id="x1-15004x2">While <!--l. 339--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>s</mi></mrow></math>
         is not exhausted:
         <!--l. 341--><p class="noindent" >
             </p><ol  class="enumerate2" >
             <li 
  class="enumerate" id="x1-15006x1">Quantize the next sample.
             </li>
             <li 
  class="enumerate" id="x1-15008x2">Observe the output and reﬁne <!--l. 347--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>Δ</mi></mrow></math>.</li></ol>
         </li></ol>
     </li>
     <li class="itemize">  <a 
 id="decoder">
     <h5 class="subsubsectionHead"><span class="titlemark">8.0.2   </span> <a 
 id="x1-160008.0.2"></a>Decoder:</h5>
     <!--l. 352--><p class="noindent" ></a>
     </p><!--l. 354--><p class="noindent" >
         </p><ol  class="enumerate1" >
         <li 
  class="enumerate" id="x1-16002x1"><!--l. 358--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>Δ</mi> <mo 
class="MathClass-rel">←</mo> <mn>2</mn></mrow></math>.
         </li>
         <li 
  class="enumerate" id="x1-16004x2">While <!--l. 360--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>ŝ</mi></mrow></math>
         is not exhausted:
         <!--l. 362--><p class="noindent" >
             </p><ol  class="enumerate2" >
             <li 
  class="enumerate" id="x1-16006x1">“Dequantize” the next sample.
                                                                  

                                                                  
             </li>
             <li 
  class="enumerate" id="x1-16008x2">Step 2.B of the encoder.</li></ol>
         </li></ol>
     </li></ul>
<!--l. 373--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">9   </span> <a 
 id="x1-170009"></a>The Jayant quantizer <span class="cite">[<a 
href="#Xjayant1974digital">1</a>]</span></h3>
     <ul class="itemize1">
     <li class="itemize">Adaptive quantization with a one word memory (<!--l. 376--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><msub><mrow 
><mi 
>Δ</mi></mrow><mrow 
><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>t</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow><mo 
class="MathClass-close">)</mo></mrow></mrow></msub 
></mrow></math>).
     </li>
     <li class="itemize">A Jayant quantider deﬁnes the Step 2.B. as: Deﬁne a multiplier <!--l. 379--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><msub><mrow 
><mi 
>M</mi></mrow><mrow 
><mi 
>l</mi></mrow></msub 
></mrow></math>
     for each quantization level <!--l. 379--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>l</mi></mrow></math>,
     where for the inner levels <!--l. 380--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><msub><mrow 
><mi 
>M</mi></mrow><mrow 
><mi 
>l</mi></mrow></msub 
> <mo 
class="MathClass-rel">&#x003C;</mo> <mn>1</mn></mrow></math>
     and for the outer levels <!--l. 380--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><msub><mrow 
><mi 
>M</mi></mrow><mrow 
><mi 
>l</mi></mrow></msub 
> <mo 
class="MathClass-rel">&#x003E;</mo> <mn>1</mn></mrow></math>,
     and compute:
<div class="par-math-display"><!--l. 382--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" ><mrow 
>
                        <msup><mrow 
><mi 
>Δ</mi></mrow><mrow 
><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi 
>n</mi></mrow><mo 
class="MathClass-close">]</mo></mrow></mrow></msup 
> <mo 
class="MathClass-rel">=</mo> <msup><mrow 
><mi 
>Δ</mi></mrow><mrow 
><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi 
>n</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow><mo 
class="MathClass-close">]</mo></mrow></mrow></msup 
><msup><mrow 
><msub><mrow 
><mi 
>M</mi></mrow><mrow 
>
<mi 
>l</mi></mrow></msub 
></mrow><mrow 
><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi 
>n</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow><mo 
class="MathClass-close">]</mo></mrow></mrow></msup 
><mo 
class="MathClass-punc">,</mo>
</mrow></math></div>
     <!--l. 384--><p class="nopar" >
     </p><!--l. 386--><p class="noindent" >where <!--l. 386--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><msup><mrow 
><mi 
>Δ</mi></mrow><mrow 
><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi 
>n</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow><mo 
class="MathClass-close">]</mo></mrow></mrow></msup 
></mrow></math>
     was the previous quantization step and <!--l. 387--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><msup><mrow 
><msub><mrow 
><mi 
>M</mi></mrow><mrow 
><mi 
>l</mi></mrow></msub 
></mrow><mrow 
><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi 
>n</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow><mo 
class="MathClass-close">]</mo></mrow></mrow></msup 
></mrow></math>
     the level multiplier for the <!--l. 387--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>n</mi> <mo 
class="MathClass-bin">−</mo> <mn>1</mn></mrow></math>-th
     (previous) sample. Thus, if the previous (<!--l. 388--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>n</mi> <mo 
class="MathClass-bin">−</mo> <mn>1</mn></mrow></math>)
     quantization used a <!--l. 389--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><msup><mrow 
><mi 
>Δ</mi></mrow><mrow 
><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi 
>n</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow><mo 
class="MathClass-close">]</mo></mrow></mrow></msup 
></mrow></math>
     too small (using outer quantization levels) then <!--l. 390--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><msup><mrow 
><mi 
>Δ</mi></mrow><mrow 
><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi 
>n</mi></mrow><mo 
class="MathClass-close">]</mo></mrow></mrow></msup 
></mrow></math>
     will be larger and viceversa.
     </p></li>
     <li class="itemize">Depending on the multipliers <!--l. 392--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>M</mi></mrow></math>,
                                                                  

                                                                  
     the quantizer will converge or oscillate. In the ﬁrst case, the quantizer will
     be good for small variations of <!--l. 394--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>s</mi></mrow></math>
     but bad when a fast adaption to large changes in <!--l. 395--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>s</mi></mrow></math>
     is required. In the second one, the quantizer will adapt quickly to fast
     variations of <!--l. 396--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>s</mi></mrow></math>
     but will oscillate when <!--l. 396--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>s</mi></mrow></math>
     changles slowly.
     </li>
     <li class="itemize">Most Jayant quantizers clip the computation of <!--l. 399--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>Δ</mi></mrow></math>
     to avoid generating a zero output quantizer in those contexts where <!--l. 400--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mi 
>s</mi></mrow></math>
     is zero or very close to zero, and to improve the adaptation to smaller
     samples after a sequence of bigger ones (avoiding to grow without limit):
<div class="par-math-display"><!--l. 405--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" ><mrow 
>
 <mtable  align="axis" style=""  
equalrows="false" columnlines="none" equalcolumns="false" class="array"><mtr><mtd 
class="array"  columnalign="left">  <mstyle 
class="text"><mtext  >if</mtext></mstyle><mspace width="1em" class="nbsp" /><msup><mrow 
><mi 
>Δ</mi></mrow><mrow 
><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi 
>n</mi></mrow><mo 
class="MathClass-close">]</mo></mrow></mrow></msup 
> <mo 
class="MathClass-rel">&#x003C;</mo> <msub><mrow 
><mi 
>Δ</mi></mrow><mrow 
><mstyle 
class="text"><mtext  >min</mtext></mstyle></mrow></msub 
><mspace width="1em" class="nbsp" /><mstyle 
class="text"><mtext  >then</mtext></mstyle><mspace width="1em" class="nbsp" /><msup><mrow 
><mi 
>Δ</mi></mrow><mrow 
><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi 
>n</mi></mrow><mo 
class="MathClass-close">]</mo></mrow></mrow></msup 
> <mo 
class="MathClass-rel">=</mo> <msub><mrow 
><mi 
>Δ</mi></mrow><mrow 
><mstyle 
class="text"><mtext  >min</mtext></mstyle></mrow></msub 
><mo 
class="MathClass-punc">,</mo> </mtd>
</mtr><mtr><mtd 
class="array"  columnalign="left"> <mstyle 
class="text"><mtext  >if</mtext></mstyle><mspace width="1em" class="nbsp" /><msup><mrow 
><mi 
>Δ</mi></mrow><mrow 
><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi 
>n</mi></mrow><mo 
class="MathClass-close">]</mo></mrow></mrow></msup 
> <mo 
class="MathClass-rel">&#x003E;</mo> <msub><mrow 
><mi 
>Δ</mi></mrow><mrow 
><mstyle 
class="text"><mtext  >max</mtext></mstyle></mrow></msub 
><mspace width="1em" class="nbsp" /><mstyle 
class="text"><mtext  >then</mtext></mstyle><mspace width="1em" class="nbsp" /><msup><mrow 
><mi 
>Δ</mi></mrow><mrow 
><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi 
>n</mi></mrow><mo 
class="MathClass-close">]</mo></mrow></mrow></msup 
> <mo 
class="MathClass-rel">=</mo> <msub><mrow 
><mi 
>Δ</mi></mrow><mrow 
><mstyle 
class="text"><mtext  >max</mtext></mstyle></mrow></msub 
><mo 
class="MathClass-punc">.</mo> </mtd></mtr><!--ll--></mtable>
</mrow></math></div>
     <!--l. 410--><p class="nopar" ></p></li></ul>
<!--l. 413--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">10   </span> <a 
 id="x1-1800010"></a>Adapting with a scale factor</h3>
     <ul class="itemize1">
     <li class="itemize">A Jayant quantized adapts the quantization step to the dynamic range
     of the signa using a set of multipiers. A similar eﬀect can be provided by
     dividing the input signal by a scale factor deﬁned iteratively as:
     <table class="equation"><tr><td> <a 
 id="x1-18001r10"></a>
                                                                  

                                                                  
     <!--l. 421--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                      <msup><mrow 
><mi 
>α</mi></mrow><mrow 
><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi 
>n</mi></mrow><mo 
class="MathClass-close">]</mo></mrow></mrow></msup 
> <mo 
class="MathClass-rel">=</mo> <msup><mrow 
><mi 
>α</mi></mrow><mrow 
><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi 
>n</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow><mo 
class="MathClass-close">]</mo></mrow></mrow></msup 
><msubsup><mrow 
><mi 
>M</mi></mrow><mrow 
>
<mi 
>l</mi></mrow><mrow 
><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi 
>n</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow><mo 
class="MathClass-close">]</mo></mrow></mrow></msubsup 
><mo 
class="MathClass-punc">.</mo>
</math></td><td class="eq-no">(10)</td></tr></table>
     </li></ul>
<!--l. 426--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">10.1   </span> <a 
 id="x1-1900010.1"></a>Example</h4>
<!--l. 427--><p class="noindent" >Quantize <a 
href="https://upload.wikimedia.org/wikipedia/commons/3/3a/Jfk_berlin_address_high.ogg" >Jfk_berlin_address_high.ogg</a> using
<!--l. 429--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow 
><mn>4</mn></mrow></math>-bits
backward adaptive Jayant quantizer. Reproduce the quantized sequence and provide
a subjective comparison with the original sequence.
</p><!--l. 433--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">11   </span> <a 
 id="x1-2000011"></a>Vector quantization</h3>
     <ul class="itemize1">
     <li class="itemize">Samples are quantized in groups (vectors).</li></ul>
<!--l. 1--><p class="noindent" >
</p>
   <h3 class="likesectionHead"><a 
 id="x1-2100011"></a>References</h3>
<!--l. 1--><p class="noindent" >
   </p><div class="thebibliography">
   <p class="bibitem" ><span class="biblabel">
 [1]<span class="bibsp">   </span></span><a 
 id="Xjayant1974digital"></a>Nuggehally S Jayant. <a 
href="https://scholar.google.es/scholar?hl=es&as_sdt=0%2C5&q=%22Digital+coding+of+speech+waveforms%3A+PCM%2C+DPCM%2C+and+DM+quantizers%22&btnG=" >Digital coding of speech waveforms: PCM, DPCM,
   and DM quantizers</a>. <span 
class="ecti-1000">Proceedings of the IEEE</span>, 62(5):611–632, 1974.
   </p>
   <p class="bibitem" ><span class="biblabel">
 [2]<span class="bibsp">   </span></span><a 
 id="Xvetterli1995wavelets"></a>Martin Vetterli and Jelena Kovacevic.  <a 
href="http://waveletsandsubbandcoding.org/Repository/VetterliKovacevic95_Manuscript.pdf" ><span 
class="ecti-1000">Wavelets and Subband Coding</span></a>.
   Prentice-hall, 1995.
</p>
   </div>
                                                                  

                                                                  
<a 
 id="Q1-1-22"></a>
    
</body> 
</html>
                                                                  


